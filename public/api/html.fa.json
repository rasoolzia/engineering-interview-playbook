{
  "meta": {
    "topic": "html",
    "language": "fa",
    "version": 1.2
  },
  "total": 25,
  "questions": [
    {
      "id": "895b0d7e",
      "title": "تفاوت `<div>` و `<span>` چیست؟",
      "difficulty": "آسان",
      "category": "اصول اولیه",
      "description": "`<div>` و `<span>` هر دو عناصر عمومی (Generic) هستند، اما در نحوه نمایش و کاربرد تفاوت دارند.\r\n\r\n**`<div>`**\r\n\r\n- عنصر block-level\r\n- کل عرض موجود را اشغال می‌کند\r\n- از خط جدید شروع می‌شود\r\n- برای گروه‌بندی بخش‌های بزرگ‌تر استفاده می‌شود\r\n\r\n**`<span>`**\r\n\r\n- عنصر inline\r\n- فقط به اندازه محتوای خود عرض می‌گیرد\r\n- از خط جدید شروع نمی‌شود\r\n- برای بخش‌های کوچک داخل متن استفاده می‌شود"
    },
    {
      "id": "4e46b19a",
      "title": "هدف از استفاده از `doctype` چیست؟",
      "difficulty": "آسان",
      "category": "اصول اولیه",
      "description": "اعلان `<!DOCTYPE>` به مرورگر اعلام می‌کند که سند با چه نسخه‌ای از HTML نوشته شده است.\r\n\r\nاهداف اصلی آن:\r\n\r\n- فعال‌سازی حالت استاندارد (Standards Mode)\r\n- جلوگیری از فعال شدن حالت سازگاری قدیمی (Quirks Mode)\r\n- تضمین رفتار صحیح CSS و Layout"
    },
    {
      "id": "d8e1047f",
      "title": "تفاوت عناصر Block و Inline چیست؟",
      "difficulty": "آسان",
      "category": "اصول اولیه",
      "description": "تفاوت این عناصر در نحوه نمایش آن‌ها در صفحه است.\r\n\r\n**عناصر Block**\r\n\r\n- از خط جدید شروع می‌شوند\r\n- کل عرض موجود را اشغال می‌کنند\r\n- می‌توانند شامل عناصر Block یا Inline باشند\r\n\r\nمثال: `<div>`، `<p>`، `<section>`\r\n\r\n**عناصر Inline**\r\n\r\n- از خط جدید شروع نمی‌شوند\r\n- فقط به اندازه محتوای خود عرض می‌گیرند\r\n- معمولاً داخل متن استفاده می‌شوند\r\n\r\nمثال: `<span>`، `<a>`، `<strong>`"
    },
    {
      "id": "342cedde",
      "title": "عناصر معنایی (Semantic) در HTML چه هستند؟",
      "difficulty": "آسان",
      "category": "اصول اولیه",
      "description": "عناصر Semantic عناصری هستند که معنای مشخصی درباره محتوای خود ارائه می‌دهند.\r\n\r\nمزایا:\r\n\r\n- بهبود دسترسی‌پذیری\r\n- بهبود سئو\r\n- خوانایی و نگهداری بهتر کد\r\n\r\nنمونه‌ها:\r\n\r\n- `<header>`\r\n- `<nav>`\r\n- `<main>`\r\n- `<article>`\r\n- `<section>`\r\n- `<footer>`\r\n\r\nبرخلاف `<div>`، این عناصر نقش مشخصی را توصیف می‌کنند."
    },
    {
      "id": "b037bd44",
      "title": "تفاوت `id` و `class` چیست؟",
      "difficulty": "آسان",
      "category": "اصول اولیه",
      "description": "`id` و `class` هر دو برای شناسایی عناصر استفاده می‌شوند اما تفاوت‌هایی دارند.\r\n\r\n**`id`**\r\n\r\n- در هر صفحه باید یکتا باشد\r\n- برای هدف‌گیری یک عنصر خاص استفاده می‌شود\r\n- معمولاً در JavaScript یا لینک‌های لنگر (anchor) کاربرد دارد\r\n\r\n**`class`**\r\n\r\n- می‌تواند روی چندین عنصر استفاده شود\r\n- برای گروه‌بندی عناصر با استایل مشابه استفاده می‌شود\r\n- رایج‌ترین روش هدف‌گیری در CSS است\r\n\r\nهر عنصر می‌تواند چندین class داشته باشد اما فقط یک id دارد."
    },
    {
      "id": "d2632486",
      "title": "هدف از ویژگی `alt` در تگ‌های `<img>` چیست؟",
      "difficulty": "آسان",
      "category": "معنایی و دسترس‌پذیری",
      "description": "ویژگی `alt` متنی جایگزین برای تصویر فراهم می‌کند زمانی که تصویر قابل نمایش نباشد یا زمانی که از فناوری‌های کمکی استفاده می‌شود.\r\n\r\nاهداف کلیدی:\r\n\r\n- **دسترس‌پذیری**: صفحه‌خوان‌ها متن alt را برای کاربران کم‌بینا می‌خوانند\r\n- **سئو**: موتورهای جستجو از متن alt برای درک محتوای تصویر استفاده می‌کنند\r\n- **بازگشتی**: اگر تصویر بارگذاری نشود، متن نمایش داده می‌شود\r\n\r\nبهترین روش:\r\n\r\n- توصیفی اما مختصر باشد\r\n- برای تصاویر تزئینی از `alt=\"\"` استفاده کنید\r\n\r\nمثال:\r\n\r\n```html\r\n<img src=\"profile.jpg\" alt=\"Portrait of Jane Doe smiling\" />\r\n```"
    },
    {
      "id": "e795d5fe",
      "title": "عناصر معنایی HTML مانند `<article>`، `<section>`، `<aside>` را توضیح دهید و اینکه چه زمانی به جای `<div>` از آنها استفاده کنیم.",
      "difficulty": "متوسط",
      "category": "معنایی و دسترس‌پذیری",
      "description": "عناصر معنایی معنای خود را به وضوح برای مرورگرها، توسعه‌دهندگان و فناوری‌های کمکی توصیف می‌کنند.\r\n\r\n- `<article>`: محتوای مستقلی که می‌تواند به تنهایی قابل استفاده باشد (مثلاً پست وبلاگ، خبر)\r\n- `<section>`: گروه‌بندی موضوعی محتوا (مثلاً فصل، مقدمه)\r\n- `<aside>`: محتوایی که به طور غیرمستقیم با محتوای اصلی مرتبط است (مثلاً نوار کناری، لینک‌های مرتبط، تبلیغات)\r\n\r\nمزایا نسبت به `<div>`:\r\n\r\n- دسترس‌پذیری بهتر (صفحه‌خوان‌ها نقش‌ها را اعلام می‌کنند)\r\n- سئوی بهبود یافته (موتورهای جستجو ساختار را بهتر درک می‌کنند)\r\n- کد قابل نگهداری‌تر"
    },
    {
      "id": "e2f9a97a",
      "title": "تفاوت‌های بین `<input type=\"number\">` و `<input type=\"tel\">` چیست؟",
      "difficulty": "متوسط",
      "category": "فرم‌ها",
      "description": "هر دو نوع ورودی برای ورودی‌های عددی مانند استفاده می‌شوند، اما رفتار متفاوتی دارند.\r\n\r\n**`type=\"number\"`**\r\n\r\n- فقط مقادیر عددی را می‌پذیرد\r\n- اعتبارسنجی داخلی دارد\r\n- در برخی مرورگرها فلش‌های افزایش/کاهش را نمایش می‌دهد\r\n- بسته به تنظیمات ممکن است کاراکترهایی مانند \"+\" یا \"-\" را رد کند\r\n\r\n**`type=\"tel\"`**\r\n\r\n- برای شماره تلفن طراحی شده\r\n- اعتبارسنجی عددی اعمال نمی‌کند\r\n- صفحه کلید عددی را در دستگاه‌های موبایل فعال می‌کند\r\n- امکان قالب‌بندی انعطاف‌پذیر را فراهم می‌کند (مثلاً +۹۸-۲۱-۱۲۳۴-۵۶۷۸)\r\n\r\nبرای شماره تلفن از `type=\"tel\"` و برای داده‌های عددی واقعی از `type=\"number\"` استفاده کنید."
    },
    {
      "id": "df269317",
      "title": "چگونه می‌توان عملکرد صفحه را با استفاده از ویژگی‌ها یا تکنیک‌های HTML بهبود بخشید؟",
      "difficulty": "متوسط",
      "category": "عملکرد",
      "description": "چندین ویژگی HTML به بهینه‌سازی بارگذاری و رندر کمک می‌کنند:\r\n\r\n- استفاده از `loading=\"lazy\"` روی `<img>` و `<iframe>` برای بارگذاری تأخیری\r\n- اضافه کردن `async` یا `defer` به تگ‌های `<script>` برای جلوگیری از مسدود شدن رندر\r\n- استفاده از `<link rel=\"preload\">`، `preconnect`، یا `dns-prefetch` برای منابع حیاتی\r\n- مشخص کردن `width` و `height` برای تصاویر جهت جلوگیری از جابجایی طرح (CLS)\r\n- استفاده از تصاویر واکنش‌گرا با `srcset` و `<picture>`\r\n\r\nاین تکنیک‌ها زمان بارگذاری را بهبود می‌بخشند، مسدودیت را کاهش می‌دهند و تجربه کاربری را ارتقا می‌دهند.\r\n\r\nمثال:\r\n\r\n```html\r\n<img src=\"large.jpg\" loading=\"lazy\" width=\"800\" height=\"600\" alt=\"...\" />\r\n<script src=\"app.js\" defer></script>\r\n```"
    },
    {
      "id": "86658f03",
      "title": "تگ `<meta name=\"viewport\">` چیست و چرا برای طراحی واکنش‌گرا مهم است؟",
      "difficulty": "آسان",
      "category": "رفتار مرورگر",
      "description": "تگ متا ویوپورت نحوه نمایش صفحه وب را در دستگاه‌های موبایل کنترل می‌کند.  \r\nبدون آن، مرورگرهای موبایل اغلب صفحات را با عرض دسکتاپ رندر کرده و سپس آنها را کوچک می‌کنند.\r\n\r\nاستفاده استاندارد:\r\n\r\n```html\r\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n```\r\n\r\n- `width=device-width`: عرض صفحه را با عرض صفحه‌نمایش دستگاه تطبیق می‌دهد\r\n- `initial-scale=1.0`: سطح زوم اولیه را تنظیم می‌کند\r\n\r\nاین تگ برای طراحی واکنش‌گرا ضروری است."
    },
    {
      "id": "2e1c436e",
      "title": "تفاوت ویژگی‌های `async` و `defer` در تگ‌های `<script>` چیست؟ تاثیر آن‌ها روی Critical Rendering Path چیست؟",
      "difficulty": "سخت",
      "category": "عملکرد",
      "description": "هر دو ویژگی `async` و `defer` بارگذاری غیرمسدودکننده اسکریپت را ممکن می‌کنند، اما زمان اجرای آن‌ها متفاوت است:\r\n\r\n- **async**:\r\n  - دانلود اسکریپت به صورت موازی انجام می‌شود\r\n  - به‌محض اتمام دانلود اجرا می‌شود (ممکن است تجزیه HTML را قطع کند)\r\n  - ترتیب اجرا بین چند اسکریپت async تضمین نمی‌شود\r\n  - مناسب اسکریپت‌های مستقل مثل آنالیتیکس و تبلیغات\r\n\r\n- **defer**:\r\n  - دانلود اسکریپت به صورت موازی انجام می‌شود\r\n  - فقط بعد از تکمیل تجزیه HTML اجرا می‌شود (کمی قبل از DOMContentLoaded)\r\n  - ترتیب اسکریپت‌ها حفظ می‌شود\r\n  - برای اسکریپت‌هایی که به DOM وابسته‌اند مناسب‌تر است\r\n\r\n**تاثیر روی Critical Rendering Path (CRP):**\r\n\r\n- بدون این ویژگی‌ها → اسکریپت مسدودکننده رندر است (تجزیه متوقف می‌شود)\r\n- `async` → ممکن است در صورت اجرای زودهنگام هنوز به رندر ضربه بزند\r\n- `defer` → برای رندر عملاً غیرمسدودکننده است\r\n\r\nبهترین روش: در اکثر سناریوها از `defer` استفاده کنید مگر اینکه اجرای فوری لازم باشد.\r\n\r\nمثال:\r\n\r\n```html\r\n<script src=\"analytics.js\" async></script>\r\n<script src=\"app.js\" defer></script>\r\n```\r\n\r\nبرای اسکریپت‌های اپلیکیشن که به ساختار DOM وابسته‌اند، `defer` معمولاً گزینه مناسب‌تری است."
    },
    {
      "id": "ed051233",
      "title": "تفاوت بین تگهای `<meta>` و هدرهای HTTP چیست و چه زمانی باید از هر کدام استفاده کرد؟",
      "difficulty": "سخت",
      "category": "سئو و متا",
      "description": "هم تگهای `<meta>` و هم هدرهای HTTP متادیتا درباره یک سند ارائه میدهند، اما در سطوح مختلفی عمل میکنند.\r\n\r\n---\r\n\r\n### تگهای `<meta>`\r\n\r\n- داخل بخش `<head>` سند HTML تعریف میشوند\r\n- متادیتایی ارائه میدهند که توسط مرورگرها و موتورهای جستجو تفسیر میشود\r\n- پس از شروع بارگذاری سند HTML پردازش میشوند\r\n\r\nمثالهای رایج:\r\n\r\n```html\r\n<meta charset=\"UTF-8\" />\r\n<meta name=\"description\" content=\"سوالات مصاحبه HTML\" />\r\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n```\r\n\r\nموارد استفاده:\r\n\r\n- توضیحات صفحه برای سئو\r\n- کدگذاری کاراکتر\r\n- پیکربندی ویوپورت\r\n\r\n---\r\n\r\n### هدرهای HTTP\r\n\r\n- توسط سرور قبل از سند HTML ارسال میشوند\r\n- رفتار مرورگر را در سطح پروتکل کنترل میکنند\r\n- معتبرتر از تگهای متا هستند\r\n\r\nمثالها:\r\n\r\n- `Content-Type`\r\n- `Cache-Control`\r\n- `Content-Security-Policy`\r\n- `Set-Cookie`\r\n\r\nموارد استفاده:\r\n\r\n- سیاستهای امنیتی\r\n- کنترل کش\r\n- ریدایرکت\r\n- مذاکره محتوا"
    },
    {
      "id": "57ca99e7",
      "title": "چند اشتباه رایج در استفاده از ARIA چیست و چرا باید HTML بومی را نسبت به ARIA در اولویت گذاشت؟",
      "difficulty": "سخت",
      "category": "معنایی و دسترسی‌پذیری",
      "description": "اشتباهات رایج:\r\n\r\n1. استفاده از ARIA وقتی معادل بومی HTML وجود دارد (مثل `role=\"button\"` روی `<div>` به جای `<button>`)\r\n2. افزودن ARIA اضافی و تکراری (مثلاً `aria-label` برای تصویری که `alt` مناسب دارد)\r\n3. فراموش کردن `aria-hidden` برای محتوای تزئینی\r\n4. تنظیم نادرست live regionها (`aria-live=\"polite\"` در مقابل `assertive`)\r\n5. مدیریت نکردن درست فوکوس کیبورد در کامپوننت‌های سفارشی\r\n\r\n**قانون طلایی (ARIA Authoring Practices):**  \r\n**\"No ARIA is better than bad ARIA\"**  \r\n**\"If you can use a native semantic element, do it\"**\r\n\r\nترتیب اولویت:\r\n\r\n1. HTML بومی (مثل button، input، nav و ...)\r\n2. نقش‌ها/حالت‌های ARIA فقط در صورت نیاز\r\n3. JavaScript برای رفتارهای پویا\r\n\r\nمثال بد → خوب:\r\n\r\n```html\r\n<!-- Bad -->\r\n<div role=\"button\" onclick=\"...\">Click</div>\r\n\r\n<!-- Good -->\r\n<button onclick=\"...\">Click</button>\r\n```\r\n\r\nاز ابزارهایی مثل Lighthouse یا axe برای شناسایی خطاهای دسترسی‌پذیری استفاده کنید."
    },
    {
      "id": "a8da7e94",
      "title": "مسیر رندر بحرانی (Critical Rendering Path) چیست و HTML چه نقشی در آن دارد؟",
      "difficulty": "سخت",
      "category": "عملکرد",
      "description": "مسیر رندر بحرانی (CRP) توالی مراحلی است که مرورگر برای رندر کردن یک صفحه طی میکند.\r\n\r\nمراحل اصلی:\r\n\r\n1. تجزیه HTML → ساخت DOM\r\n2. تجزیه CSS → ساخت CSSOM\r\n3. ترکیب در درخت رندر\r\n4. چیدمان (Layout)\r\n5. رنگ آمیزی (Paint)\r\n\r\nHTML مستقیماً بر موارد زیر تأثیر میگذارد:\r\n\r\n- اندازه و عمق DOM\r\n- ترتیب بارگذاری منابع\r\n- اسکریپت های مسدودکننده\r\n- تصاویر بدون ابعاد مشخص\r\n\r\nتکنیک های بهینه سازی HTML:\r\n\r\n- استفاده از `defer` برای اسکریپت ها\r\n- کمینه کردن عمق DOM\r\n- مشخص کردن `width` و `height` برای تصاویر\r\n- پیش بارگذاری منابع حیاتی\r\n\r\nدرک CRP برای بهینهسازی عملکرد ضروری است."
    },
    {
      "id": "c1cdee8f",
      "title": "تفاوت بین ویژگیهای `id` و `data-*` در HTML چیست و چه زمانی باید از هر کدام استفاده کرد؟",
      "difficulty": "متوسط",
      "category": "اصول اولیه",
      "description": "هر دو ویژگی `id` و `data-*` اطلاعات را به عناصر متصل میکنند، اما اهداف متفاوتی دارند.\r\n\r\n---\r\n\r\n### `id`\r\n\r\n- باید در سند یکتا باشد\r\n- برای موارد زیر استفاده میشود:\r\n  - ناوبری قطعه ای (`#section`)\r\n  - انتخاب DOM در JavaScript\r\n  - ارتباط برچسب ها (ویژگی `for`)\r\n- معنای معنایی در ساختار سند دارد\r\n\r\nمثال:\r\n\r\n```html\r\n<section id=\"pricing\"></section>\r\n```\r\n\r\n### ویژگیهای `data-*`\r\n\r\n- ویژگیهای سفارشی برای ذخیره داده های اضافی\r\n- بر معناشناسی تأثیر نمیگذارند\r\n- از طریق JavaScript قابل دسترسی هستند (`element.dataset`)\r\n\r\nمثال:\r\n\r\n```html\r\n<button data-user-id=\"42\"></button>\r\n```\r\n\r\nاز `id` برای هویت سند استفاده کنید.  \r\nاز `data-*` برای ذخیره متادیتای سفارشی استفاده کنید."
    },
    {
      "id": "0a55d887",
      "title": "تفاوت بین `<section>` و `<div>` از منظر طرح کلی سند چیست؟",
      "difficulty": "متوسط",
      "category": "معنایی و دسترسی‌پذیری",
      "description": "`<div>` یک کانتینر عمومی بدون معنای معنایی است.\r\n\r\n`<section>` نشاندهنده گروهبندی موضوعی محتوا است و به طرح کلی سند کمک میکند.\r\n\r\nتفاوتهای کلیدی:\r\n\r\n- `<section>` معمولاً باید شامل یک عنوان باشد\r\n- ساختار را به فناوریهای کمکی و موتورهای جستجو اعلام میکند\r\n- `<div>` صرفاً ساختاری است و ارزش معنایی ندارد\r\n\r\nاز `<section>` زمانی استفاده کنید که محتوا بخش منطقی از سند را نشان میدهد.  \r\nاز `<div>` فقط زمانی استفاده کنید که هیچ عنصر معنایی مناسبی وجود ندارد."
    },
    {
      "id": "cbac043e",
      "title": "`<template>` و Shadow DOM در Web Components چگونه با هم کار می‌کنند و چه مسائلی را حل می‌کنند؟",
      "difficulty": "سخت",
      "category": "رفتار مرورگر و HTML مدرن",
      "description": "`<template>` و Shadow DOM دو بخش اصلی Web Components هستند:\r\n\r\n- `<template>`: قطعه HTML که parse می‌شود اما inert است (رندر یا side effect ندارد تا زمانی که clone شود)\r\n- Shadow DOM: زیردرخت DOM کپسوله‌شده که به یک عنصر سفارشی متصل می‌شود (استایل و DOM ایزوله می‌ماند)\r\n\r\nاین دو در کنار هم این مشکلات را حل می‌کنند:\r\n\r\n- نشت استایل (CSS کامپوننت روی کل صفحه اثر نمی‌گذارد)\r\n- تداخل در انتخاب DOM (جلوگیری از conflict در `querySelector`)\r\n- قابلیت استفاده مجدد بدون وابستگی به فریمورک (مثل React/Vue)\r\n\r\nنمونه پایه:\r\n\r\n```html\r\n<template id=\"my-card\">\r\n  <style>\r\n    .card {\r\n      border: 1px solid;\r\n      padding: 1em;\r\n    }\r\n  </style>\r\n  <div class=\"card\"><slot name=\"title\"></slot></div>\r\n</template>\r\n\r\n<script>\r\n  class MyCard extends HTMLElement {\r\n    constructor() {\r\n      super();\r\n      const shadow = this.attachShadow({ mode: 'open' });\r\n      const template = document\r\n        .getElementById('my-card')\r\n        .content.cloneNode(true);\r\n      shadow.appendChild(template);\r\n    }\r\n  }\r\n  customElements.define('my-card', MyCard);\r\n</script>\r\n\r\n<my-card><span slot=\"title\">Hello</span></my-card>\r\n```\r\n\r\nمزیت‌ها: مستقل از فریمورک، کارآمد، و آینده‌نگر."
    },
    {
      "id": "aa182576",
      "title": "ویژگی `sandbox` در `<iframe>` چگونه کار می‌کند و چرا برای امنیت مهم است؟",
      "difficulty": "سخت",
      "category": "رفتار مرورگر و امنیت",
      "description": "ویژگی `sandbox` دسترسی‌های `<iframe>` را محدود می‌کند و یک لایه امنیتی در برابر محتوای مخرب اضافه می‌کند.\r\n\r\nمقادیر رایج (با فاصله از هم):\r\n\r\n- (خالی) → بیشترین محدودیت‌ها (امن‌ترین حالت)\r\n- `allow-scripts` → اجازه اجرای JavaScript\r\n- `allow-same-origin` → در نظر گرفتن iframe به عنوان same-origin (ریسک‌دار)\r\n- `allow-popups` → اجازه باز کردن پنجره جدید\r\n- `allow-forms` → اجازه ارسال فرم\r\n\r\nحالت پیش‌فرض (`sandbox=\"\"`) این موارد را غیرفعال می‌کند:\r\n\r\n- ناوبری\r\n- اسکریپت‌ها\r\n- فرم‌ها\r\n- افزونه‌ها\r\n- دور زدن سیاست same-origin\r\n\r\nکاربرد مهم: جاسازی محتوای third-party (مثل تبلیغات، HTML تولیدشده توسط کاربر، پیش‌نمایش‌ها).\r\n\r\nمثال (جاسازی امن):\r\n\r\n```html\r\n<iframe\r\n  src=\"https://example.com/widget\"\r\n  sandbox=\"allow-scripts allow-same-origin\"\r\n></iframe>\r\n```\r\n\r\nبدون `sandbox` احتمال ریسک‌هایی مثل XSS یا clickjacking افزایش پیدا می‌کند."
    },
    {
      "id": "05b2beb0",
      "title": "تفاوت بین `<link>` و `<a>` در HTML چیست؟",
      "difficulty": "متوسط",
      "category": "اصول اولیه",
      "description": "هر دو روابط ایجاد میکنند، اما اهداف متفاوتی دارند.\r\n\r\n### `<a>` (لنگر)\r\n\r\n- هایپرلینک داخل محتوای صفحه ایجاد میکند\r\n- قابل مشاهده و تعاملی است\r\n- برای ناوبری استفاده میشود\r\n\r\nمثال:\r\n\r\n```html\r\n<a href=\"/about\">درباره ما</a>\r\n```\r\n\r\n### `<link>`\r\n\r\n- روابط بین سند و منابع خارجی را تعریف میکند\r\n- داخل `<head>` قرار میگیرد\r\n- برای کاربران قابل مشاهده نیست\r\n\r\nکاربردهای رایج:\r\n\r\n- استایلشیت ها\r\n- Preload / Prefetch\r\n- آیکون ها\r\n\r\nمثال:\r\n\r\n```html\r\n<link rel=\"stylesheet\" href=\"styles.css\" />\r\n```\r\n\r\n`<a>` برای ناوبری کاربر است.  \r\n`<link>` برای روابط منابع در سطح سند است."
    },
    {
      "id": "a889b6ea",
      "title": "Web Components در HTML چیست و چه فناوری های اصلی آنها را فعال میکنند؟",
      "difficulty": "سخت",
      "category": "رفتار مرورگر",
      "description": "Web Components امکان ایجاد عناصر سفارشی قابل استفاده مجدد و کپسوله شده را فراهم میکنند.\r\n\r\nآنها بر اساس چهار فناوری اصلی ساخته شده اند:\r\n\r\n1. **Custom Elements** – تعریف تگ های HTML جدید\r\n2. **Shadow DOM** – زیردرخت DOM کپسوله شده\r\n3. **HTML Templates** – نشانهگذاری قابل استفاده مجدد\r\n4. **ES Modules** – JavaScript ماژولار\r\n\r\nمفهوم مثال:\r\n\r\n```html\r\n<user-card></user-card>\r\n```\r\n\r\nمزایا:\r\n\r\n- کپسوله سازی\r\n- قابلیت استفاده مجدد\r\n- کامپوننت های مستقل از فریمورک\r\n\r\nWeb Components معماری کامپوننت بومی را بدون اتکا به فریمورک های خارجی فعال میکنند."
    },
    {
      "id": "e402bdc9",
      "title": "`<picture>` + `srcset` + `sizes` چگونه برای تصاویر واکنش‌گرا با هم کار می‌کنند و چرا برای تصاویر از media queryهای CSS بهتر هستند؟",
      "difficulty": "سخت",
      "category": "عملکرد",
      "description": "این ترکیب بدون نیاز به JavaScript امکان art direction و انتخاب رزولوشن مناسب را فراهم می‌کند:\r\n\r\n- `<picture>`: ظرفی برای چند `<source>` مختلف\r\n- `srcset`: فهرستی از گزینه‌های تصویر (با descriptorهایی مثل 1x، 2x یا width)\r\n- `sizes`: عرض تقریبی نمایش تصویر را در شرایط مختلف media به مرورگر اعلام می‌کند\r\n\r\nمرورگر بر اساس این موارد بهترین تصویر را انتخاب می‌کند:\r\n\r\n- نسبت پیکسلی دستگاه (DPR)\r\n- عرض viewport\r\n- فرمت‌های قابل پشتیبانی (مثل WebP)\r\n\r\nچرا بهتر از media queryهای CSS برای تصویر است؟\r\n\r\n- مرورگر قبل از دانلود تصمیم می‌گیرد (صرفه‌جویی در پهنای باند)\r\n- درخواست HTTP اضافی برای تشخیص لازم نیست\r\n- پشتیبانی از art direction (کراپ‌های متفاوت در breakpointهای مختلف)\r\n\r\nمثال:\r\n\r\n```html\r\n<picture>\r\n  <source media=\"(min-width: 800px)\" srcset=\"large.jpg 1x, large-2x.jpg 2x\" />\r\n  <source media=\"(min-width: 400px)\" srcset=\"medium.jpg\" />\r\n  <img\r\n    src=\"small.jpg\"\r\n    srcset=\"small.jpg 400w, medium.jpg 800w\"\r\n    sizes=\"(max-width: 400px) 100vw, 800px\"\r\n    alt=\"...\"\r\n  />\r\n</picture>\r\n```\r\n\r\nاین روش مصرف دیتا را کم می‌کند و Core Web Vitals (به‌خصوص LCP) را بهبود می‌دهد."
    },
    {
      "id": "9f941501",
      "title": "اعتبارسنجی فرم در HTML5 چگونه کار می‌کند و با Constraint Validation API چطور می‌توان اعتبارسنجی سفارشی ساخت؟",
      "difficulty": "سخت",
      "category": "فرم‌ها",
      "description": "HTML5 اعتبارسنجی داخلی فرم را با ویژگی‌هایی مثل `required`، `pattern`، `min/max` و بررسی نوع ورودی (مثل email و url) فراهم می‌کند.\r\n\r\nفرآیند کلی:\r\n\r\n- مرورگر هنگام submit یا focusout اعتبارسنجی می‌کند (با `novalidate` می‌توان غیرفعالش کرد)\r\n- برای فیلد نامعتبر پیام خطای پیش‌فرض مرورگر نمایش داده می‌شود\r\n- امکان افزودن خطای سفارشی با JavaScript وجود دارد\r\n\r\n**Constraint Validation API**:\r\n\r\n- دسترسی از طریق `element.validity` (شامل وضعیت‌هایی مثل `valueMissing` و `patternMismatch`)\r\n- تعریف خطای سفارشی با `element.setCustomValidity('Error message')` (برای پاک کردن، رشته خالی)\r\n- اجرای بررسی با `element.reportValidity()` یا `form.checkValidity()`\r\n\r\nچرا این موضوع سخت است؟ چون موضوعاتی مثل i18n، اعتبارسنجی async (مثلاً یکتابودن username) و سازگاری مرورگرهای قدیمی مطرح می‌شوند.\r\n\r\nمثال (اعتبارسنجی سفارشی دامنه ایمیل):\r\n\r\n```html\r\n<form>\r\n  <input id=\"email\" type=\"email\" required pattern=\"[^@]+@example\\.com\" />\r\n  <button type=\"submit\">Submit</button>\r\n</form>\r\n\r\n<script>\r\n  const email = document.getElementById('email');\r\n  email.addEventListener('input', () => {\r\n    if (email.value.endsWith('@gmail.com')) {\r\n      email.setCustomValidity('Only @example.com allowed');\r\n    } else {\r\n      email.setCustomValidity('');\r\n    }\r\n  });\r\n</script>\r\n```\r\n\r\nاین API با ARIA هم برای دسترسی‌پذیری یکپارچه است (مثلاً `aria-invalid`)."
    },
    {
      "id": "07942592",
      "title": "چطور می‌توان داده‌های ساخت‌یافته را با schema.org در HTML پیاده‌سازی کرد و چه مزایایی برای SEO دارد؟",
      "difficulty": "سخت",
      "category": "سئو و متا",
      "description": "داده ساخت‌یافته با JSON-LD، Microdata یا RDFa محتوا را با واژگان schema.org برچسب‌گذاری می‌کند تا موتور جستجو entityها را بهتر بفهمد (مثل Product، Event، Recipe).\r\n\r\nفرمت پیشنهادی: JSON-LD داخل `<script type=\"application/ld+json\">` (ساده‌تر و بدون شلوغ‌کردن markup).\r\n\r\nمزایا:\r\n\r\n- Rich snippetها (مثل ستاره و قیمت در نتایج جستجو)\r\n- crawlability بهتر (برای قابلیت‌هایی مثل Knowledge Graph)\r\n- کمک به voice search و featured snippet\r\n- احتمال بهبود رتبه به‌صورت غیرمستقیم (به‌خاطر درک بهتر محتوا)\r\n\r\nچالش‌ها: اعتبارسنجی با ابزارهای Structured Data و جلوگیری از spam (باید با محتوای قابل مشاهده تطابق داشته باشد).\r\n\r\nمثال (Product schema):\r\n\r\n```html\r\n<script type=\"application/ld+json\">\r\n  {\r\n    \"@context\": \"https://schema.org\",\r\n    \"@type\": \"Product\",\r\n    \"name\": \"Wireless Headphones\",\r\n    \"image\": \"headphones.jpg\",\r\n    \"description\": \"Noise-cancelling over-ear headphones\",\r\n    \"offers\": {\r\n      \"@type\": \"Offer\",\r\n      \"price\": \"199.99\",\r\n      \"priceCurrency\": \"USD\"\r\n    },\r\n    \"aggregateRating\": {\r\n      \"@type\": \"AggregateRating\",\r\n      \"ratingValue\": \"4.5\",\r\n      \"reviewCount\": \"89\"\r\n    }\r\n  }\r\n</script>\r\n```\r\n\r\nبرای صفحات کلیدی پیاده‌سازی کنید و با ابزار rich results تست بگیرید."
    },
    {
      "id": "fd750173",
      "title": "ویژگی `contenteditable` چیست، خطاهای رایج آن کدام‌اند و چطور می‌توان آن را دسترس‌پذیر کرد؟",
      "difficulty": "سخت",
      "category": "رفتار مرورگر",
      "description": "`contenteditable=\"true\"` یک عنصر را برای ویرایش کاربر قابل‌ویرایش می‌کند (شبیه ویرایشگر متن غنی).\r\n\r\nرفتار:\r\n\r\n- روی هر عنصری قابل اعمال است\r\n- به فرزندان به ارث می‌رسد مگر اینکه override شود\r\n- مرورگر ویرایش پایه را مدیریت می‌کند (مثل Ctrl+B) اما رفتارها یکسان نیستند\r\n\r\nمشکلات رایج:\r\n\r\n- امنیت: باید ورودی sanitize شود تا XSS رخ ندهد\r\n- ناسازگاری بین مرورگرها (مثلاً رفتار Paste)\r\n- کنترل نداشتن روی undo stack بومی\r\n- افت کارایی در محتوای حجیم\r\n- چالش دسترسی‌پذیری (بدون role پیش‌فرض مناسب ARIA)\r\n\r\nبرای دسترس‌پذیری بهتر:\r\n\r\n- افزودن ARIA مثل `role=\"textbox\"` یا `role=\"region\"`، `aria-label` و `aria-multiline=\"true\"`\r\n- مدیریت کیبورد: فوکوس، حرکت با کلیدها\r\n- استفاده از `execCommand` یا Clipboard API مدرن برای قابلیت‌های ویرایش\r\n\r\nمثال (ویرایشگر ساده):\r\n\r\n```html\r\n<div\r\n  contenteditable=\"true\"\r\n  role=\"textbox\"\r\n  aria-multiline=\"true\"\r\n  aria-label=\"Editable area\"\r\n>\r\n  Edit me!\r\n</div>\r\n\r\n<script>\r\n  const editor = document.querySelector('[contenteditable]');\r\n  editor.addEventListener('input', (e) => {\r\n    // Sanitize: e.target.innerHTML = sanitize(e.target.innerHTML);\r\n  });\r\n</script>\r\n```\r\n\r\nبرای محیط production معمولاً از کتابخانه‌هایی مثل Quill یا ProseMirror استفاده می‌شود."
    },
    {
      "id": "d67173aa",
      "title": "Resource hintها در HTML (`preload`، `prefetch`، `preconnect`، `dns-prefetch`) چه هستند و هرکدام را چه زمانی برای بهینه‌سازی عملکرد استفاده می‌کنیم؟",
      "difficulty": "سخت",
      "category": "عملکرد",
      "description": "Resource hintها (در قالب `<link rel=\"...\">`) به مرورگر می‌گویند منابع را زودتر resolve/fetch کند تا latency کم شود.\r\n\r\n- **preload**: بارگذاری زودهنگام منابع حیاتی (مثل فونت یا اسکریپت ضروری). برای اولویت درست، `as=\"type\"` مهم است.\r\n- **prefetch**: بارگذاری کم‌اولویت و حدسی برای ناوبری بعدی (مثلاً منابع صفحه بعد).\r\n- **preconnect**: برقراری زودهنگام اتصال TCP و handshake امنیتی برای دامنه‌های third-party.\r\n- **dns-prefetch**: فقط resolve کردن DNS (سبک‌تر از preconnect، مناسب تعداد زیادی دامنه).\r\n\r\nترتیب هزینه تقریبی: dns-prefetch (کمترین) < preconnect < prefetch < preload (بیشترین اولویت).\r\n\r\nمزایا: کاهش TTFB و بهبود FCP/LCP در Core Web Vitals.\r\n\r\nنکته: استفاده بیش‌ازحد باعث هدررفت پهنای باند می‌شود؛ با Lighthouse تست کنید.\r\n\r\nمثال:\r\n\r\n```html\r\n<!-- Preload critical font -->\r\n<link rel=\"preload\" href=\"font.woff2\" as=\"font\" type=\"font/woff2\" crossorigin />\r\n\r\n<!-- Preconnect to CDN -->\r\n<link rel=\"preconnect\" href=\"https://cdn.example.com\" crossorigin />\r\n\r\n<!-- DNS prefetch for analytics -->\r\n<link rel=\"dns-prefetch\" href=\"https://analytics.com\" />\r\n\r\n<!-- Prefetch next page -->\r\n<link rel=\"prefetch\" href=\"/next-page.html\" />\r\n```\r\n\r\nبرای محتوای بالای صفحه (above-the-fold) از preload و برای مسیرهای ناوبری بعدی از prefetch استفاده کنید."
    }
  ]
}